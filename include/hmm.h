#pragma once
#include <iostream>
#include <vector>
#include <string>
#include <Eigen/Dense>

/*!
 * Hidden Markov Model with Gaussian emissions.
 * Author: Zixuan
 */
struct BaseHMM {
  int N;                          /* number of states; Q = {1, 2, 3, ..., N} */
  int random_seed;                /* A random number generator seed. */
  int max_epoch;                  /* Maximum number of epoch to update the patameters. */
  bool verbose;                   /* Whether to rint the convergence reports. */
  Eigen::MatrixXd *A;             /* NxN matrix. A[i][j] is the transition prob 
                                    of going from state i at time t to state j at 
                                    time t + 1. */
  Eigen::VectorXd *pi;            /* Initial state probability. */
  double tol;                     /* Convergence threshold */

  /*!
   * \brief Compute the log probability and posteriors under the model.
   * \param X The observation.
   * \param lengths The lengths of individual sequences.
   * \return logprob Log likelihood of the observation X.
   * \return State-membership probabilities for each sample in X.
   */
  void score_samples(const std::vector<double>& X, const std::vector<int>& lengths,
                     double *logprob, Eigen::MatrixXd& posteriors);

  /*!
   * \brief Compute the log probability under the model.
   * \param X The observation.
   * \param lengths The lengths of individual sequences.
   * \return logprob Log likelihood of the observation X.
   */
  void score(const std::vector<double>& X, const std::vector<int>& lengths,
             double *logprob);

  /*!
   * \brief Decode the latent variable using Viterbi algorithm.
   * \param X Observation sequence.
   * \return logprob Log likelihood of the observation X.
   * \return state_sequence Decoded latent variable sequence.
   */
  void _decode_viterbi(const std::vector<double>& X,
                       double *logprob, Eigen::VectorXd& state_sequence);

  /*!
   * \brief Decode the latent variable using Maximum Posteriors
   * \param X Obervation sequence.
   * \return logprob Log likelihood of the observation X.
   * \return state_sequence Decoded latent variable sequence.
   */
  void _decode_map(const std::vector<double>& X,
                   double *logprob, Eigen::VectorXd& state_sequence);

  /*!
   * \brief Find the most likely latent variable sequence corresponding to X.
   * \param X The observaton sequence.
   * \param length Lengths of individual sequences.
   * \param algorithm Decoder algorithm. Must be one of "viterbi" or "map".
   * \return logprob Log likelihood of the observation X.
   * \return state_sequence Decoded latent variable sequence.
   */
  void decode(const std::vector<double>& X, const std::vector<int>& lengths,
              void (*decoder)(const std::vector<double>&, double *, Eigen::VectorXd&),
              double *logprob, Eigen::VectorXd& state_sequence);

  /*!
   * \brief Find the most likely latent variable sequence corresponding to X.
   * \param X The observation sequence.
   * \param length Lengths of individual sequences.
   * \return state_sequence Decoded latent variable sequence.
   */
  void predict(const std::vector<double>& X, const std::vector<int>& lengths,
               Eigen::VectorXd& state_sequence);
  
  /*!
   * \brief Compute the posterior probability for each state in the model.
   * \param X The observation sequence.
   * \param lengths Lengths of individual sequences.
   * \return posteriors Latent variable probabilities for each sample in X.
   */
  void predict_proba(const std::vector<double>& X,
                     const std::vector<int>& lengths,
                     Eigen::MatrixXd& posteriors);
  
  /*!
   * \brief Generate random samples from the hmm model.
   * \param n_samples Number of samples to generate.
   * \param random_seed Random number generator seed.
   * \return X Observation.
   * \return state_sequence Latent variable generated by the model.
   */
  void sample(int n_samples, int random_seed, std::vector<double>& X,
              Eigen::VectorXd& state_sequence);

  /*!
   * \brief Estimate model parameters
   * \param X Obeservation sequences.
   * \param lengths Lengths of individual sequences.
   */
  void fit(const std::vector<double>& X, const std::vector<int>& lengths);

  /*!
   * \brief Viterbi algorithm.
   * \param framelogprob Log likelihood per component under the model.
   * \return logprob Log likelihood.
   * \return state_sequence Decoded latent variable sequences.
   */
  void _do_viterbi_pass(Eigen::MatrixXd& framelogprob, double *logprob,
                        Eigen::VectorXd& state_sequence);
  
  /*!
   * \brief Forward pass algorithm.
   * \param framelogprob Log likelihood per component under the model.
   * \return logprob Log likelihood.
   * \return alpha
   */
  void _do_forward_pass(Eigen::MatrixXd& framelogprob, double *logprob,
                        Eigen::MatrixXd& alpha);

  /*!
   * \brief Backward pass algorithm.
   * \param framelogprob Log likelihood per component under the model.
   * \return beta
   */
  void _do_backward_pass(Eigen::MatrixXd& framelogprob, Eigen::MatrixXd& beta);

  /*!
   * \brief Compute posteriors per component under the model.
   * \param alpha
   * \param beta
   * \return log_gamma
   */
  void _compute_posteriors(Eigen::MatrixXd& alpha, Eigen::MatrixXd& beta, Eigen::MatrixXd& log_gamma);

  /*!
   * \brief Initializes model parameters prior to fitting.
   * \param X Observation sequence.
   */
  void _init(const std::vector<double>& X);

  /*! 
   * \brief Compute per-component log probability under the model.
   * \param X Observation sequence.
   * \return logprob Log probability of each sample in X for each of the
   *         model states.
   */
  virtual void _compute_log_likelihood(const std::vector<double>& X, 
                                       Eigen::MatrixXd& logprob) = 0;

  /*!
   * \brief Generates a random sample from a given component.
   * \param state Index of the component to condition on.
   * \param random_seed Random number generator seed.
   * \return X Generated observation sequence. Each sample is generated from
   *           the emission distribution corresponding to a given component.
   */
  virtual void _generate_sample_from_state(size_t state,
                                           int random_seed,
                                           std::vector<double>& X) = 0;

  /*!
   * \brief Initializes sufficient statistics required for M-step.
   * \return n_observations
   * \return start
   * \return trans
   */
  virtual void _initialize_sufficient_statistics(size_t *n_observations,
                                                 Eigen::VectorXd *&start,
                                                 Eigen::MatrixXd *&trans) = 0;

  /*!
   * \brief Updates sufficient statistics from a given sample.
   * \param n_observations
   * \param start
   * \param trans
   * \param X
   * \param framelogprob
   * \param posteriors
   * \param fwdlattice
   * \param bwdlattice
   */
  virtual void _accumulate_sufficient_statistics(int n_observations,
                                                 Eigen::VectorXd start,
                                                 Eigen::MatrixXd& trans,
                                                 const std::vector<double>& X,
                                                 Eigen::MatrixXd& framelogprob,
                                                 Eigen::MatrixXd& posteriors,
                                                 Eigen::MatrixXd& alpha,
                                                 Eigen::MatrixXd& beta);
  
  /*!
   * \brief Performs the M-step of EM algorithm.
   * \param n_observations
   * \param start
   * \param trans
   */
  virtual void _do_mstep(int n_observations, Eigen::VectorXd& start, Eigen::MatrixXd& trans);

  /*!
   * \brief Deconstructor
   */
  ~BaseHMM();
};