#pragma once
#include <iostream>
#include <vector>
#include <string>
#include <Eigen/Dense>

/*!
 * Hidden Markov Model with Gaussian emissions.
 * Author: Zixuan
 */
struct BaseHMM {
  size_t N;                          /* number of states; Q = {1, 2, 3, ..., N} */
  int random_seed;                /* A random number generator seed. */
  size_t max_epoch;                  /* Maximum number of epoch to update the patameters. */
  bool verbose;                   /* Whether to rint the convergence reports. */
  Eigen::ArrayXXd *A;             /* NxN matrix. A[i][j] is the transition prob 
                                    of going from state i at time t to state j at 
                                    time t + 1. */
  Eigen::ArrayXd *pi;             /* Initial state probability. */
  double tol;                     /* Convergence threshold */

  BaseHMM(size_t N = 2, int random_seed = 47, size_t max_epoch = 10,
          double tol = 1e-4, bool verbose = true) 
    : N(N), random_seed(random_seed), max_epoch(max_epoch),
      tol(tol), verbose(verbose) {
  double init_value = 1./N;
  pi = new Eigen::ArrayXd(N);
  *pi = init_value * Eigen::ArrayXd::Ones(N);
  A = new Eigen::ArrayXXd(N, N);
  *A = init_value * Eigen::ArrayXXd::Ones(N, N);
};

  /*!
   * \brief Compute the log probability and posteriors under the model.
   * \param X The observation.
   * \param lengths The lengths of individual sequences.
   * \return logprob Log likelihood of the observation X.
   * \return State-membership probabilities for each sample in X.
   */
  void score_samples(const std::vector<double>& X, const std::vector<int>& lengths,
                     double *logprob, Eigen::ArrayXXd& posteriors);

  /*!
   * \brief Compute the log probability under the model.
   * \param X The observation.
   * \param lengths The lengths of individual sequences.
   * \return logprob Log likelihood of the observation X.
   */
  void score(const std::vector<double>& X, const std::vector<int>& lengths,
             double *logprob);

  /*!
   * \brief Decode the latent variable using Viterbi algorithm.
   * \param X Observation sequence.
   * \return logprob Log likelihood of the observation X.
   * \return state_sequence Decoded latent variable sequence.
   */
  void _decode_viterbi(const std::vector<double>& X,
                       double *logprob, Eigen::ArrayXi& state_sequence);

  /*!
   * \brief Decode the latent variable using Maximum Posteriors
   * \param X Obervation sequence.
   * \return logprob Log likelihood of the observation X.
   * \return state_sequence Decoded latent variable sequence.
   */
  void _decode_map(const std::vector<double>& X,
                   double *logprob, Eigen::ArrayXi& state_sequence);

  /*!
   * \brief Find the most likely latent variable sequence corresponding to X.
   * \param X The observaton sequence.
   * \param length Lengths of individual sequences.
   * \param algorithm Decoder algorithm. Must be one of "viterbi" or "map".
   * \return logprob Log likelihood of the observation X.
   * \return state_sequence Decoded latent variable sequence.
   */
  void decode(const std::vector<double>& X, const std::vector<int>& lengths,
              void (BaseHMM::*decoder)(const std::vector<double>&, double *, Eigen::ArrayXi&),
              double *logprob, Eigen::ArrayXi& state_sequence);

  /*!
   * \brief Find the most likely latent variable sequence corresponding to X.
   * \param X The observation sequence.
   * \param length Lengths of individual sequences.
   * \return state_sequence Decoded latent variable sequence.
   */
  void predict(const std::vector<double>& X, const std::vector<int>& lengths,
               Eigen::ArrayXi& state_sequence);
  
  /*!
   * \brief Compute the posterior probability for each state in the model.
   * \param X The observation sequence.
   * \param lengths Lengths of individual sequences.
   * \return posteriors Latent variable probabilities for each sample in X.
   */
  void predict_proba(const std::vector<double>& X,
                     const std::vector<int>& lengths,
                     Eigen::ArrayXXd& posteriors);
  
  /*!
   * \brief Generate random samples from the hmm model.
   * \param n_samples Number of samples to generate.
   * \param random_seed Random number generator seed.
   * \return X Observation.
   * \return state_sequence Latent variable generated by the model.
   */
  void sample(size_t n_samples, int random_seed, std::vector<double>& X,
              Eigen::ArrayXi& state_sequence);

  /*!
   * \brief Estimate model parameters
   * \param X Obeservation sequences.
   * \param lengths Lengths of individual sequences.
   */
  void fit(const std::vector<double>& X, const std::vector<int>& lengths);

  /*!
   * \brief Viterbi algorithm.
   * \param framelogprob Log likelihood per component under the model.
   * \return logprob Log likelihood.
   * \return state_sequence Decoded latent variable sequences.
   */
  void _do_viterbi_pass(Eigen::ArrayXXd& framelogprob, double *logprob,
                        Eigen::ArrayXi& state_sequence);
  
  /*!
   * \brief Forward pass algorithm.
   * \param framelogprob Log likelihood per component under the model.
   * \return logprob Log likelihood.
   * \return alpha
   */
  void _do_forward_pass(Eigen::ArrayXXd& framelogprob, double *logprob,
                        Eigen::ArrayXXd& alpha);

  /*!
   * \brief Backward pass algorithm.
   * \param framelogprob Log likelihood per component under the model.
   * \return beta
   */
  void _do_backward_pass(Eigen::ArrayXXd& framelogprob, Eigen::ArrayXXd& beta);

  /*!
   * \brief Compute posteriors per component under the model.
   * \param alpha
   * \param beta
   * \return log_gamma
   */
  void _compute_posteriors(Eigen::ArrayXXd& alpha, Eigen::ArrayXXd& beta, Eigen::ArrayXXd& log_gamma);

  /*!
   * \brief Initializes model parameters prior to fitting.
   * \param X Observation sequence.
   */
  virtual void _init(const std::vector<double>& X);

  /*! 
   * \brief Compute per-component log probability under the model.
   * \param X Observation sequence.
   * \return logprob Log probability of each sample in X for each of the
   *         model states.
   */
  virtual void _compute_log_likelihood(const std::vector<double>& X, 
                                       Eigen::ArrayXXd& logprob) = 0;

  /*!
   * \brief Generates a random sample from a given component.
   * \param state Index of the component to condition on.
   * \param random_seed Random number generator seed.
   * \return X Generated observation sequence. Each sample is generated from
   *           the emission distribution corresponding to a given component.
   */
  virtual void _generate_sample_from_state(size_t state,
                                           int random_seed,
                                           std::vector<double>& X) = 0;

  /*!
   * \brief Initializes sufficient statistics required for M-step.
   * \return n_observations
   * \return start
   * \return trans
   */
  virtual void _initialize_sufficient_statistics(size_t *n_observations,
                                                 Eigen::ArrayXd &start,
                                                 Eigen::ArrayXXd &trans);

  /*!
   * \brief Updates sufficient statistics from a given sample.
   * \param n_observations
   * \param start
   * \param trans
   * \param X
   * \param framelogprob
   * \param posteriors
   * \param fwdlattice
   * \param bwdlattice
   */
  virtual void _accumulate_sufficient_statistics(size_t *n_observations,
                                                 Eigen::ArrayXd& start,
                                                 Eigen::ArrayXXd& trans,
                                                 const std::vector<double>& X,
                                                 Eigen::ArrayXXd& framelogprob,
                                                 Eigen::ArrayXXd& posteriors,
                                                 Eigen::ArrayXXd& alpha,
                                                 Eigen::ArrayXXd& beta);
  
  /*!
   * \brief Performs the M-step of EM algorithm.
   * \param n_observations
   * \param start
   * \param trans
   */
  virtual void _do_mstep(size_t n_observations, Eigen::ArrayXd& start, Eigen::ArrayXXd& trans);

  /*!
   * \brief Deconstructor
   */
  ~BaseHMM();
};